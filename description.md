# Автоматско одредување на комплексност на алгоритми со динамичко програмирање

## Динамичко програмирање

Динамичко програмирање, за прв пат се споменува од страна на Richard E. Bellman во педесеттите години од минатиот век, кој што ја поставил основата на динамичкото програмирање на цврста математичка основа. Оваа револуционерно нова техника во тоа време, придонесува за развој на новиот метод за решавање на проблеми кои што имаат сопствена карактеристична хиерархија: Проблеми кои во себе содржат повеќе поедноставни подпроблеми од исти тип.

Процесот на решавање на „главниот“ проблем, започнува со решавање на наједноставните проблеми кој се содржи во главниот проблем и вредностите на тие решенија се меморираат (во табела) за да понатаму истите се искористат за добивање на следните решенија на подроблемите, се до решение на главниот проблем. Ваквиот метод за решавање на големи проблеми претставува моќна алатка за дизајнирање соодветни алгоритами. Овој метод, во литературата е познат и како метод на обратна индукција, односно процес на размислување по обратен редослед (од крајот кон почетокот на решението). Целта на овој метод е да се пронајде оптимален редослед на чекори на решението на главниот проблем. 

За да може врз еден проблем да се примени метод на динамичко програмирање, проблемот треба да има соодветна хиерархија, односно да поседува две клучни карактеристики :
- Оптимална подструктура, т.е. ако решението на тој проблем може да се добие преку решенијата на неговите подпроблеми.  
- Подпроблеми кои се препокриваат

Постојат два пристапи кон решавање на проблемите со динамичко програмирање: одгоре надолу и оддолу нагоре. Пристапот одгоре надолу користи техника која се нарекува мемоизација. Мемоизација е поим карактеристичен во компјутерските науки и истиот е за прв пат дефиниран од страна на Donald Michie, 1968. Целта na мемоизација е да се меморира резултатот од решавањето на еден подпроблем, за да при повторно повикување на тој подпроблем, решението само да се вчита од табела, наместо повторно да се решава. Најчесто оваа техника се применува кај рекурзивни големи проблеми, преку решавање на неговите подпроблеми ( доколку тие подпроблеми се повторуваат).  

Пристапот оддолу нагоре се состои во формулирање на еден сложен проблем како серија од рекурзивни и поедноставни проблеми. Оваа серија на подпроблеми е изработена на тој начин што секое наредно решение се добива како комбинација на еден или повеќе претходно решени подпроблеми. Според тоа, врз основа на претходно добиените решенија за подпроблемите и нивно надградување, се добиваат решенија за поголемите подпроблеми се до добивање на решение за првичниот проблем. Решенијата кои се добиваат во меѓувреме се зачувуваат во табела за да се избегне непотребно повторување на веќе решен подпроблем.

## Дефиниција за проблем и за алгоритам со решенија
Со цел да се направи поточна евалуација на различните алгоритми за решавање на ист проблем, како метрика најчесто се користи нивното време на извршување, како и количината на ресурси (најчесто мемориски) кои алгоритамот ги користи. Таквите мерења се директни, и независни од самиот алгоритам, бидејќи мерат надворешно набљудливи ефекти на извршувањето.  

Но, во повеќето модерни системи, ваквиот пристап знае да биде недоверлив, бидејќи околината во која се извршува алгоритмот може да се менува за време на извршувањето, т.е. ресурсите (време и меморија) потрошени од еден алгоритам може да зависат не само од самиот алгоритам, ами и од оптеретеноста на самиот систем. Стандардно решение за вакво мерење на перформанси е алгоритамот да се изврши, со иста почетна состојба, многу пати, и потоа, откако ќе се исфрлат екстремните вредности, да се земе просечна вредност на потрошувачката на ресурси.  
Иако ваквиот начин на евалуација е корисен, сепак, не ни дава експлицитна вредност за комплексноста на некој алгоритам, ами само апроксимативна, емпириска вредност. Исто така, иако може да се добие податок дека еден алгоритам е, например, побрз од друг за одредено множество влезни податоци, немаме никаква информација околу причините зошто е тоа така.

Во изработката на овој труд, искористениот пристап е различен. Имено, иако е измерено времето потребно за извршување на некој алгоритам, главниот акцент е ставен на одредени метрики дефинирани од самиот проблем.  
На пример, доколку треба да споредуваме алгоритми за сортирање на низа во место, алгоритамот, каков и да е, ќе мора да извршува некои операции, имено, ќе мора да се изврши пристап до одреден елемент од низата, ќе мора да се споредат два елементи од низата, и ќе мора да се сменат местата на два елементи од низата.  
Овие операции се дефинирани како метрики на самиот проблем, и секој алгоритам за решавање на проблемот, е потребно да ги пресмета и достави вредностите на овие метрики за анализа.  

При извршувањето на алгоритмите, тие се извршуваат повеќе пати, но не со исто множество на влезни параметри, туку, влезните параметри се строго подредени спрема некој критериум, на пример, за сортирање на низи во место, влезниот параметер е низа со се поголема должина.

### Имплементација на дефинициите и нивно извршување и споредување
Специфичната имплементација на опишаните дефиниции е изработена преку интерфејси во TypeScript.  
Дефиницијата на проблем (**`ProblemOptions`**) се состои од:
- името на проблемот
- имиња на метриките кои треба да се достават од алгоритмите кој ќе го решаваат овој проблем
- низа од прогресивно покомплексни вредности кои ќе бидат искористени како влезни параметри за алгоритмите. Можни се две опции, имено, да се зададат експлицитно специфични вредности, или да се зададе функција (`type InputFunction<T> = (index: number) => T;`) на која ќе и биде зададен редниот број на извршувањето, а која ќе ни ги врати потребните влезни параметри.
- број на тестови кои треба да се извршат (опционален параметар доколку се зададат вредностите експлицитно). Доколку параметарот не е наведен, вредност која се подразбира е 100.

```typescript
export interface ProblemOptions {
    name: string;
    metricNames: string[];
    inputs: any[] | InputFunction<any>;
    inputLength?: number;
}
```

Самите алгоритми (**`Algorithm`**)се дефинирани со помош на следниот интерфејс:
```typescript
export interface Algorithm {
    name: string;
    problemName: string;
    metrics: MetricMap;
    run(input: any): any;
    reset(): void;
}

export type MetricMap = { [key: string]: Metric };
export type Metric = () => number;
```
каде што 
- name е името на самиот алгоритам, и може да биде произволна вредност, се додека не е иста со име на друг алгоритам за истиот проблем
- problemName е името на проблемот кој овој алгоритам го решава, и мора да биде исто со името искористено за дефинирање на проблемот.
- metrics е мапа од функции кои може да се искористат за превземање на метриките после извршување на алгоритмот за некоја зададена влезна вредност
- run е функција која ќе биде искористена при извршувањето на алгоритмот, и која од наша перспектива го енкапсулура самиот алгоритам.
- reset е функција која ќе биде повиката откога ќе биде извршен алгоритмот и превземени метриките, со цел да може алгоритмот да се реиницијализира на почетна состојба, и да се осигураме дека метриките нема да може да се мешаат помеѓу различни извршувања на алгоритмот.

Дефинициите на проблемите и алгоритмите се спојуваат заедно во класата **`AlgorithmComparer`** чиј конструктор ја прима дефиницијата на проблемот како параметар.

```typescript
export class AlgorithmComparer {
    ...
    constructor(private options: ProblemOptions) {
        ...
```
Потоа, со помош на функцијата `registerAlgorithm` е можно да се регистрираат алгоритми кои го решаваат тој проблем. При регистрацијата се проверува
- дали алгоритамот го решава точниот проблем
- дали алгоритамот ги експонира своите метрики
- дали метриките кои алгоритамот ги експонира комплетно одговараат со метриките побарани од проблемот
- дали името на алгоритмот е единствено за тој проблем

Доколку овие проверки се успешни, алгоритамот се регистрира.

По успешната регистрација на сите алгоритми, може да се пристапи кон нивното извршување, преку методата `runAlgorithms`, која сукцесивно ги вчитува или генерира податоците, и потоа ги изврушува алгоритмите. После извршувањето на одреден алгоритам, неговите метрики се превземаат и се складираат во полето со резултати.

## Комплексност на алгоритми и начини за проценка на комплексноста
Наједноставна дефиниција на комплексност од аспект на алгоритми, би била едноставна релација помеѓу големината на влезните параметри на еден алгоритам, и потребните ресурси за да се изврши алгоритамот, т.е. потребниот број на чекори (време) или потребниот број на мемориски локации за да се изврши. Притоа, колку оваа релација е "порамна" т.е. поблиску до x-оската, за толку го сметаме алгоритамот за поефикасен, т.е. алгоритам кој зависи линеарно од големината на влезот, е поефикасен од алгоритам кој зависи квадратно од големината на влезот.

Во оваа релација, најчесто единствениот фокус е на големината на самиот влез, при што секакви адитивни, па дури и мултипликативни константи се занемаруваат. Причината за тоа е што чест случај во извршувањето на алгоритмите е големината на нивните влезови да варира со неколку редови на величина. На пример, можно е еден алгоритам да зависи линеарно од влезот, и да има потреба од 1.000 чекори за секоја единица влез, т.е. за влез 1 извршува 1.000 чекор, за влез 2 извршува 2.000, итн.

Да го споредеме овој алгоритам со друг, кој за секоја единица влез, извршува 1 чекор за кубот на влезот, т.е. за влез 1 извршува 1 чекор, за влез 2 извршува 8 чекори, за влез 3 - 27 чекори, итн...  
За мали броеви, предноста во бројот на чекори е комплетно на страна на вториот алгоритам, но доколку влезот порасне за неколку реда на магнитуда (што често се случува во практични сценарија) ситуацијата драматично се менува. На пример, за влез 1.000, првиот алгоритам ќе изврши 1.000.000 чекори, додека вториот 1.000.000.000 чекори, т.е. првиот алгоритам ќе биде илјада пати побрз од другиот.

Затоа, најчесто, комплексноста на алгоритмите се проценува во асимптотска смисла, т.е. која би била природата на зависноста доколу големината на влезот тежнее кон бесконечност, и се користат таканаречените големо-о, големо-омега и големо-тета нотации. На пример, покажано е дека линеарното пребарување на низа е пропорционално со бројот на членови на низата n, или има O(n), т.е. се извршува во линарно време, додека бинарното пребарување е пропорционално со логаритамот на бројот на членови, т.е. има O(log(n)) или се извршува во логаритамско време.

Исто така, во општ случај, бројот на чекори кои ќе се извршат зависи не само од големината на влезните податоци, ами и од самите нивни вредности. Бидејќи вредностите, во принцип, не можат да бидат контролирани, во најголем број од случаите, овие нотации за релацијата за комплексност на алгоритамот даваат горна граница, т.е. најлош случај на влез на алгоритамот.

### Имплементација на анализа на комплексноста на метрика
Откако ќе бидат извршени алгоритмите, и нивните метрики ќе бидата достапни, може да се изврши анализа на нивната комплексност. Анализата се врши од страна на имплементација на **`IAnalyzer`** интерфејсот, деклариран со

```typescript
export interface IAnalyzer {
    analyzeMetrics(metrics: number[]): Complexity;
}
```
каде што **`Complexity`** е енумерација со следните вредности

```typescript
export enum Complexity {
    Constant = "constant",
    Linear = "linear",
    Square = "square",
    Logarithmic = "logarithmic",
    Exponential = "exponential",
    LinearLog = "linear-log",
    Unknown = "unknown"
}
```
 Доколку корисникот не зададе своја имплементација на `IAnalyzer`, ќе биде искористена имплементацијата во **`Analyzer`** класата. Оваа имплементација користи елементарна нумеричка диференцијација за да го оцени трендот на вредностите, и притоа дава соодветен резултат.

## Практични примери

### Фибоначиеви броеви

Фибоначиевите броеви се броеви со рекурзивна дефиниција, имено, првите два фибоначиеви броеви се 1 и 1, а секој останат фибоначиев број е збир од претходните два фибоначиеви броеви. Следната функција е наивна имплементација на оваа дефиниција:

```typescript
public fibbonaci(value: number): number {
    if ([1, 0].includes(value)) {
        return 1;
    }

    return this.fibbonaci(value - 1) + this.fibbonaci(value - 2);
}
```
Соодветно, проблемот кој ќе се решава е да се одреди соодветниот фибоначиев број за зададен ненегативен цел број. Поради рекурзивната природа на самата дефиниција, метрика која може да се користи во евалуација на комплексноста на одреден алгоритам за решавање на овој проблем, ќе биде бројот на рекурзивни повици кои се потребни за да се добие едно решение.

Изработени се два алгоритма за решавање, при што првиот ја користи наивната верзија (`BruteForceFibbonaci`), додека вториот користи динамичко програмирање преку мемоизација (`DynamicFibbonaci`). Во него, при иницијализацијата на алгоритамот, се креира мапа со решенија

```typescript
private cache: NumberMap = {
    0: 1,
    1: 1
};
```
и потоа, за време на извршување, доколку влезниот параметар е содржан како клуч во мапата, веднаш како резултат се враќа вредноста за тој клуч. Доколку влезниот параметар не е содржан во мапата, се пресметува неговата вредност (со наивниот пристап), и потоа добиената вредност, пред да се врати како резултат, се зачувува во мапата.

```typescript
public fibbonaci(value: number) {
    if (this.cache[value] !== undefined){
        return this.cache[value]
    }
    const result = this.fibbonaci(value - 1) + this.fibbonaci(value - 2);
    this.cache[value] = result;
    return result;
}
```

Влезните податоци кои се искористени се природните броеви од 1 до 40. Добиените резултати со споредба на овие два алгоритми се:

```
Algoritm Name: bruteForceFibbonaci
  Total run time: 12.6s
  Metric: callCount, Estimated complexity: exponential
Algoritm Name: dynamicFibbonaci
  Total run time: 0.00s
  Metric: callCount, Estimated complexity: linear
```

При што комплетните метрики за последните неколку вредности се:

```json
Наивен алгоритам: 
Влез: 37, Време на извршување 1.896s, Број на повици:  78.176.337
Влез: 38, Време на извршување 2.984s, Број на повици: 126.491.971
Влез: 39, Време на извршување 4.665s, Број на повици: 204.668.309
```

```json
Динамички алгоритам: 
Влез: 37, Време на извршување <1ms, Број на повици: 73
Влез: 38, Време на извршување <1ms, Број на повици: 75
Влез: 39, Време на извршување <1ms, Број на повици: 77
```

## Алгоритам на Дијкстра за минимален пат низ граф
Многу проблеми во програмирањето се сведуваат на анализа на графови, т.е. објекти кои се составени од јазли, и гранките помеѓу тие јазли. Голем дел од овие проблеми немаат познати решенија со полиномна комплексност, т.е. припаѓаат во класата на NP проблеми. Еден од нив е и проблемот за најкраток пат помеѓу одреден почетен и одреден краен јазел. Наивната имплементација на решение на овој проблем е преку генерирање на сите можни патишта, и споредување на нивната вкупна цена. Овој пристап, меѓутоа, има екстремно висока комплексност, односно зависи експоненцијално од бројот на влезни јазли и гранките помеѓу нив.

Од друга страна, проблемите со графови доста добро се решаваат со помош на динамичко програмирање, заради тоа што ги задоволуваат условите за да може да има динамички алгоритам за нивно решавање. На пример, структурата на самите графови е таква, што подмножество од јазли и гранки, повторно претставува граф. Овие особини биле искористени во 1956-та од Едсгер Дајкстра за дизајн на динамички алгоритам за најкраток пат низ граф. Анализираната комплексност на овој алгоритам е O(e+v _log_ v), каде `e` е бројот на гранки, а `v` бројот на јазли.

Соодветно, изработени се два алгоритми за пронаоѓање на најкраток пат низ граф, соодветно со наивна имплементација, и со помош на алгоритамот на Дајкстра. Метриката која е поставена е едноставно броење на пристапот кон информациите за одреден јазел. Добиените резултати одговараат на предвиденото.

```
Algoritm Name: Naive implementation
  Total run time: 26.4s
  Metric: nodeAccess, Estimated complexity: exponential
Algoritm Name: Dijkstra's algorithm
  Total run time: 0.10s
  Metric: nodeAccess, Estimated complexity: linear-log
```

## Секвенцијално множење на матрици

Оптималниот алгоритам за множење на две матрици е сеуште еден од нерешените проблеми на програмирањето, но во секој случај, множењето на две матрици е процес кој завзема значителни ресурси. Тоа што е јасно е дека сите алгоритми за множење на матрици зависат од големината на матриците, со степен што (најверојатно) е стриктно поголем од 2, при што наивниот пристап за множење на матрици има кубна комплексност. Во анализата на проблемот, ќе претпоставеме дека за самото множење на матриците ќе се користи наивниот пристап.

Чест случај при работа со матрици е потреба од секвенцијално множење на повеќе од две матрици. Бидејќи множењето на матрици е асоцијативно, доколку треба да помножеме три матрици, `A*B*C`, крајниот резултат ќе биде ист, без разлика дали множењето ќе биде имплементирано како `(A*B)*C` или како `A*(B*C)`. Слично, доколку имаме 4 матрици, имаме 5 различни начини на кои можеме да ги помножиме (`((A*B)*C)*D`, `(A*B)*(C*D)`, `(A*(B*C))*D)`, `A*((B*C)*D)` и `A*(B*(C*D))`). Не сите овие начини ќе бидат идентични од перспектива на број на операции кои треба да се извршат. На пример, доколку имаме три матрици со големини 2x10, 10x3 и 3x4, резултатот и на двата начина ќе биде 2x4 матрица, но доколку го најдеме како `(A*B)*C`, ќе треба да извршеме `2*10*3+2*3*4=84` множења, а доколку го најдеме како `A*(B*C)` ќе треба да извршеме `10*3*4+2*10*4=180` множења. Очигледно е дека првиот пристап би бил повеќе од двапати поефикасен од вториот, без разлика на вредностите на самите матрици и на алгоритамот искористен за нивно множење.

Проблемот во овој случај се сведува да се најде најоптималниот начин да се постават заградите, т.е. редоследот на множење на зададена низа од матрици. Наивниот пристап е да се генерираат сите можни комбинации (суштински, сите пермутации на редоследот на операции), да се евалуираат, и од нив да се избере најдобрата. Бидејќи бројот на пермутации е зависен од факториелот на бројот на матрици, комплексноста на овој пристап е експоненцијална.

Алтернативен, но еквивалентен (со еквивалента комплексност) е следниот рекурзивен пристап
- Подели ја низата на матрици на две поднизи
- Најди го минималната цена за множење на секоја подниза.
- Цената на множење е збир од цените за секоја подниза плус цената на множење на двете поднизи.
- Повтори го алгоритмот за секоја позиција на која можеме да ја поделеме низата на матрици.

Оваа варијанта на наивниот пристап е имплементирана. Имплементирано е и динамичко подобрување на оваа варијанта, бидејќи горниот алгоритам е подложен на мемоизација. Имено, голем дел од подпроблемите се повторуваат, т.е. повторно и повторно ќе биде одредувано оптималното множење за некоја дадена подниза. Доколку овие вредности се пресметуваат само еднаш, и се памтат, комплексноста на алгортмот драматично паѓа, што може да се види и од резултатите добиени со извршување:

```
Algoritm Name: Naive chain matrix multiplication
  Total run time: 116.3s
  Metric: callCount, Estimated complexity: exponential
Algoritm Name: Dynamic chain matrix multiplication
  Total run time: 3.42s
  Metric: callCount, Estimated complexity: cube
```

Метриката која е искористена е бројот на повици на рекурзивната функција. Вреди да се напомене дека кубната комплексност на динамичкиот алгоритам е сеуште релативно висока, но очигледно е драматично пониска од наивната имплементација.

## Сортирање на низа

Сортирањето на низи е еден од најчестите и најдобро проучените проблеми во програмирањето. Постојат многу алгоритми за сортирање, со најразлични комплексности. Изработени се две споредби на три алгоритми за сортирање, Bubble Sort, Quick Sort и Merge Sort, при што како метрики се земени бројот на пристапи кон елементите од низата, бројот на споредби помеѓу елементи од низата, како и бројот на замени на елементи од низата. Сите три алгоритми се имплементирани преку сортирање "во место", така што не се креираат помошни низи со копии од елементите, туку се сортира самата предадена низа.  

Двете споредби се разликуваат во природата на низите кои треба да се сортираат, имено едната споредба користи низа со случајно генерирани елементи, додека втората споредба е сортирање на веќе сортирана низа. Треба да се спомне и дека за анализа на резултатите од овие метрики се користи различен анализатор, со поголема толеранција, бидејќи резултатите за случајно генерираните елементи не се комплетно детерминистички.

Добиените податоци за случајно избраните вредности се следни:

```
Algoritm Name: Bubble sort
  Total run time: 15.9s
  Metric: comparisons, Estimated complexity: square
  Metric: swaps, Estimated complexity: square
  Metric: accesses, Estimated complexity: square
Algoritm Name: Quick Sort
  Total run time: 0.0140s
  Metric: comparisons, Estimated complexity: linear-log
  Metric: swaps, Estimated complexity: linear-log
  Metric: accesses, Estimated complexity: linear-log
Algoritm Name: Merge Sort
  Total run time: 0.0100s
  Metric: comparisons, Estimated complexity: linear-log
  Metric: swaps, Estimated complexity: linear-log
  Metric: accesses, Estimated complexity: linear-log
```

Додека вредностите при сортирање на веќе сортирана низа се следни:

```
Algoritm Name: Bubble sort
  Total run time: 5.91s
  Metric: comparisons, Estimated complexity: square
  Metric: swaps, Estimated complexity: constant
  Metric: accesses, Estimated complexity: square
Algoritm Name: Quick Sort
  Total run time: 1.52s
  Metric: comparisons, Estimated complexity: square
  Metric: swaps, Estimated complexity: linear
  Metric: accesses, Estimated complexity: square
Algoritm Name: Merge Sort
  Total run time: 0.00100s
  Metric: comparisons, Estimated complexity: linear-log
  Metric: swaps, Estimated complexity: constant
  Metric: accesses, Estimated complexity: linear-log
```

Од споредба на резултатите се гледа дека комплексноста на алгоритмите на сортирање зависи и од самите податоци кои се сортираат, специфично, вториот случај е одбран да биде најлош можен случај за алгоритмот Quick Sort - кој, иако во просечен случај е O(n *log* n) алгоритам, во најлошиот случај е квадратен алгоритам. За разлика од него, Merge Sort алгоритамот, и во најлошиот случај, сеуште ја задржува својата комплексност од O(n *log* n).

## Заклучок

Од вредностите кои се добиени со споредба на алгоритмите со и без динамичко програмирање, може да се заклучи дека динамичкото програмирање е моќна техника со која можеме да реализираме пресметки на алгоритми со извонредно големи временски комплексности, чие нединамичко извршување би траело исклучителна количина на време, додека динамичките верзии неретко имаат линеарна комплексност.  

Забелешка кон динамичкото програмирање е дека е применливо само на специфична класа на проблеми, како и дека, во принцип, користи значително повеќе меморија за зачувување на меѓурезултати кои најчесто не му се релевантни (или дури ни достапни) на крајниот корисник. Но, со оглед на се поголемата достапност на меморија, во најголем дел од случаите оваа промена на време за меморија, дава повеќе од прифатливи резултати.

Драстичен пример за тоа е ситуацијата со фибоначиевите броеви, каде по цена од една едноставна мапа од броеви, со вкупна величина под 1KB, се добива забрзување од неколку милиони пати. И не само тоа, динамичката верзија може да се користи за генерирање на поголем опсег на броеви, бидејќи времето потребно за генерирање на броевите над 50 со наивниот алгоритам, дури и на денешен модерен хардвер, станува значајно.

## Ресурси

Кодот за компараторот и анализатор се наоѓа на [оваа локација](https://github.com/zstefanovska/algo-comparer), и е исто така објавен како npm пакет на [оваа локација](https://www.npmjs.com/package/algo-comparer). Може да биде инсталиран како node модул со командата `npm install algo-comparer`. Во рамките на овој пакет се наоѓаат и имплементациите за фибоначиеви броеви, како и алгоритми кои ги тестираат анализаторот и компараторот.

Кодот за имплементација на алгоритмите се наоѓа на [оваа локација](https://github.com/zstefanovska/algo-comparer-demo).

Овој документ е пристапен [тука](https://github.com/zstefanovska/algo-comparer/blob/master/description.md)

