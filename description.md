# Автоматско одредување на комплексност на алгоритми со динамичко програмирање

## Динамичко програмирање

Тука доаѓа делот со дефиниции за што е динамичко програмирање, кои проблеми ги решава и како

## Дефиниција за проблем и за алгоритам со решенија
Со цел да се направи поточна евалуација на различните алгоритми за решавање на ист проблем, како метрика најчесто се користи нивното време на извршување, како и количината на ресурси (најчесто мемориски) кои алгоритамот ги користи. Таквите мерења се директни, и независни од самиот алгоритам, бидејќи мерат надворешно набљудливи ефекти на извршувањето.  
Но, во повеќето модерни системи, ваквиот пристап знае да биде недоверлив, бидејќи околината во која се извршува алгоритмот може да се менува за време на извршувањето, т.е. ресурсите (време и меморија) потрошени од еден алгоритам може да зависат не само од самиот алгоритам, ами и од оптеретеноста на самиот систем. Стандардно решение за вакво мерење на перформанси е алгоритамот да се изврши, со иста почетна состојба, многу пати, и потоа, откако ќе се исфрлат екстремните вредности, да се земе просечна вредност на потрошувачката на ресурси.  
Иако ваквиот начин на евалуација е корисен, сепак, не ни дава експлицитна вредност за комплексноста на некој алгоритам, ами само апроксимативна, емпириска вредност. Исто така, иако може да се добие податок дека еден алгоритам е, например, побрз од друг за одредено множество влезни податоци, немаме никаква информација околу причините зошто е тоа така.
Во изработката на овој труд, искористениот пристап е различен. Имено, иако е измерено времето потребно за извршување на некој алгоритам, главниот акцент е ставен на одредени метрики дефинирани од самиот проблем.  
На пример, доколку треба да споредуваме алгоритми за сортирање на низа во место, алгоритамот, каков и да е, ќе мора да извршува некои операции, имено, ќе мора да се изврши пристап до одреден елемент од низата, ќе мора да се споредат два елементи од низата, и ќе мора да се сменат местата на два елементи од низата.  
Овие операции се дефинирани како метрики на самиот проблем, и секој алгоритам за решавање на проблемот, е потребно да ги пресмета и достави вредностите на овие метрики за анализа.  
При извршувањето на алгоритмите, тие се извршуваат повеќе пати, но не со исто множество на влезни параметри, туку, влезните параметри се строго подредени спрема некој критериум, на пример, за сортирање на низи во место, влезниот параметер е низа со се поголема должина.

### Имплементација на дефинициите
Специфичната имплементација на опишаните дефиниции е изработена преку интерфејси во TypeScript.  
Дефиницијата на проблем (**`ProblemOptions`**) се состои од:
- името на проблемот
- имиња на метриките кои треба да се достават од алгоритмите кој ќе го решаваат овој проблем
- низа од прогресивно покомплексни вредности кои ќе бидат искористени како влезни параметри за алгоритмите. Можни се две опции, имено, да се зададат експлицитно специфични вредности, или да се зададе функција (`type InputFunction<T> = (index: number) => T;`) на која ќе и биде зададен редниот број на извршувањето, а која ќе ни ги врати потребните влезни параметри.
- број на тестови кои треба да се извршат (опционален параметар доколку се зададат вредностите експлицитно)

```typescript
export interface ProblemOptions {
    name: string;
    metricNames: string[];
    inputs: any[] | InputFunction<any>;
    inputLength?: number;
}
```

Самите алгоритми се дефинирани со помош на следниот интерфејс:
```typescript
export interface Algorithm {
    name: string;
    problemName: string;
    metrics: MetricMap;
    run(input: any): any;
    reset(): void;
}

export type MetricMap = { [key: string]: Metric };
export type Metric = () => number;
```
каде што 
- name е името на самиот алгоритам, и може да биде произволна вредност
- problemName е името на проблемот кој овој алгоритам го решава, и мора да биде исто со името искористено за дефинирање на проблемот.
- metrics е мапа од функции кои може да се искористат за превземање на метриките после извршување на алгоритмот за некоја зададена влезна вредност
- run е функција која ќе биде искористена при извршувањето на алгоритмот
- reset е функција која ќе биде повиката откога ќе биде извршен алгоритмот и превземени метриките, со цел да може алгоритмот да се реиницијализира на почетна состојба, и да се осигураме дека метриките нема да може да се мешаат помеѓу различни извршувања на алгоритмот.



## Комплексност на алгоритми и начини за проценка на комплексноста

## Практични примери

### Фибоначиеви броеви

Фибоначиевите броеви се броеви со рекурзивна дефиниција, имено, првите два фибоначиеви броеви се 1 и 1, а секој останат фибоначиев број е збир од претходните два фибоначиеви броеви. Следната функција е наивна имплементација на оваа дефиниција:

```typescript
public fibbonaci(value: number): number {
    if ([1, 0].includes(value)) {
        return 1;
    }

    return this.fibbonaci(value - 1) + this.fibbonaci(value - 2);
}
```
Соодветно, проблемот кој ќе се решава е да се одреди соодветниот фибоначиев број за зададен ненегативен цел број. Поради рекурзивната природа на самата дефиниција, метрика која може да се користи во евалуација на комплексноста на одреден алгоритам за решавање на овој проблем, ќе биде бројот на рекурзивни повици кои се потребни за да се добие едно решение.

Изработени се два алгоритма за решавање, при што првиот ја користи наивната верзија (`BruteForceFibbonaci`), додека вториот користи динамичко програмирање преку мемоизација (`DynamicFibbonaci`). Во него, при иницијализацијата на алгоритамот, се креира мапа со решенија

```typescript
private cache: NumberMap = {
    0: 1,
    1: 1
};
```
и потоа, за време на извршување, доколку влезниот параметар е содржан како клуч во мапата, веднаш како резултат се враќа вредноста за тој клуч. Доколку влезниот параметар не е содржан во мапата, се пресметува неговата вредност (со наивниот пристап), и потоа добиената вредност, пред да се врати како резултат, се зачувува во мапата.

```typescript
public fibbonaci(value: number) {
    if (this.cache[value] !== undefined){
        return this.cache[value]
    }
    const result = this.fibbonaci(value - 1) + this.fibbonaci(value - 2);
    this.cache[value] = result;
    return result;
}
```

Влезните податоци кои се искористени се природните броеви од 1 до 40. Добиените резултати со споредба на овие два алгоритми се:

```
Algoritm Name: bruteForceFibbonaci
  Total run time: 12.6s
  Metric: callCount, Estimated complexity: exponential
Algoritm Name: dynamicFibbonaci
  Total run time: 0.00s
  Metric: callCount, Estimated complexity: linear
```

При што комплетните метрики за последните неколку вредности се:

```json
Наивен алгоритам: 
Влез: 37, Време на извршување 1.896s, Број на повици:  78.176.337
Влез: 38, Време на извршување 2.984s, Број на повици: 126.491.971
Влез: 39, Време на извршување 4.665s, Број на повици: 204.668.309
```

```json
Динамички алгоритам: 
Влез: 37, Време на извршување <1ms, Број на повици: 73
Влез: 38, Време на извршување <1ms, Број на повици: 75
Влез: 39, Време на извршување <1ms, Број на повици: 77
```

## Алгоритам на Дијкстра за минимален пат низ граф

##

##

## Сортирање на низа